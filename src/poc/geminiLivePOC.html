<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Live POC - 4 Simultaneous Sessions</title>
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #1a1a1a;
            color: #fff;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .character-session {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            border: 2px solid transparent;
        }

        .character-session.active {
            border-color: #10b981;
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.3);
        }

        .character-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .character-name {
            font-size: 18px;
            font-weight: 600;
        }

        .status {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
        }

        .status.connected {
            background: #10b981;
            color: #000;
        }

        .status.disconnected {
            background: #ef4444;
        }

        .status.active {
            background: #8b5cf6;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .transcript {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 12px;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 15px;
            font-size: 14px;
            line-height: 1.6;
        }

        .audio-indicator {
            display: flex;
            gap: 4px;
            align-items: center;
            padding: 8px;
            background: #1a1a1a;
            border-radius: 6px;
        }

        .audio-bar {
            width: 3px;
            height: 20px;
            background: #10b981;
            border-radius: 2px;
            animation: audioBar 0.5s ease-in-out infinite;
        }

        .audio-bar:nth-child(2) { animation-delay: 0.1s; }
        .audio-bar:nth-child(3) { animation-delay: 0.2s; }
        .audio-bar:nth-child(4) { animation-delay: 0.3s; }

        @keyframes audioBar {
            0%, 100% { height: 10px; }
            50% { height: 25px; }
        }

        .controls {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        input, select {
            background: #1a1a1a;
            border: 1px solid #3a3a3a;
            color: #fff;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
        }

        input {
            flex: 1;
        }

        select {
            min-width: 200px;
        }

        button {
            background: #8b5cf6;
            color: #fff;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            background: #7c3aed;
            transform: translateY(-1px);
        }

        button:disabled {
            background: #4a4a4a;
            cursor: not-allowed;
            transform: none;
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        .log {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 15px;
            max-height: 150px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin-top: 15px;
        }

        .log-entry {
            margin-bottom: 5px;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <h1>üéôÔ∏è Gemini Live POC - 4 Simultaneous Character Sessions</h1>
    <p style="opacity: 0.7; margin-bottom: 30px;">
        This POC demonstrates managing 4 Gemini Live WebSocket sessions where only one character is "active" at a time.
        The active character receives input and responds with audio + transcript.
    </p>

    <div class="container">
        <!-- Wario Session -->
        <div class="character-session" id="session-player2">
            <div class="character-header">
                <div class="character-name">üßô Wario Amadeuss</div>
                <div class="status disconnected" id="status-player2">Disconnected</div>
            </div>
            <div class="transcript" id="transcript-player2">
                <em>Waiting for connection...</em>
            </div>
            <div class="audio-indicator" id="audio-player2" style="display: none;">
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <span style="margin-left: 10px; font-size: 12px;">Speaking...</span>
            </div>
        </div>

        <!-- Domis Session -->
        <div class="character-session" id="session-player3">
            <div class="character-header">
                <div class="character-name">‚ôüÔ∏è Domis Hassoiboi</div>
                <div class="status disconnected" id="status-player3">Disconnected</div>
            </div>
            <div class="transcript" id="transcript-player3">
                <em>Waiting for connection...</em>
            </div>
            <div class="audio-indicator" id="audio-player3" style="display: none;">
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <span style="margin-left: 10px; font-size: 12px;">Speaking...</span>
            </div>
        </div>

        <!-- Scan Session -->
        <div class="character-session" id="session-player4">
            <div class="character-header">
                <div class="character-name">‚ö° Scan Ctrl+Altman</div>
                <div class="status disconnected" id="status-player4">Disconnected</div>
            </div>
            <div class="transcript" id="transcript-player4">
                <em>Waiting for connection...</em>
            </div>
            <div class="audio-indicator" id="audio-player4" style="display: none;">
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <span style="margin-left: 10px; font-size: 12px;">Speaking...</span>
            </div>
        </div>

        <!-- President Session -->
        <div class="character-session" id="session-moderator">
            <div class="character-header">
                <div class="character-name">üëî President (Dorkesh Cartel)</div>
                <div class="status disconnected" id="status-moderator">Disconnected</div>
            </div>
            <div class="transcript" id="transcript-moderator">
                <em>Waiting for connection...</em>
            </div>
            <div class="audio-indicator" id="audio-moderator" style="display: none;">
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <div class="audio-bar"></div>
                <span style="margin-left: 10px; font-size: 12px;">Speaking...</span>
            </div>
        </div>
    </div>

    <div class="controls">
        <div class="input-group">
            <input type="text" id="messageInput" placeholder="Type your message here..." />
            <select id="targetCharacter">
                <option value="player2">üßô Wario</option>
                <option value="player3">‚ôüÔ∏è Domis</option>
                <option value="player4">‚ö° Scan</option>
                <option value="moderator">üëî President</option>
            </select>
        </div>
        <div class="button-group">
            <button id="initAudio">üîä Enable Audio</button>
            <button id="connectAll">üîå Connect All Sessions</button>
            <button id="sendMessage">üì§ Send to Active Character</button>
            <button id="disconnectAll">üî¥ Disconnect All</button>
        </div>

        <div class="log" id="log">
            <div class="log-entry">Ready to connect...</div>
        </div>
    </div>

    <script type="module">
        // POC Configuration
        const API_KEY = 'AIzaSyCny_Nsi6wvPqubcLEw0b45cKhOSH9k8pw';

        const sessions = new Map();
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        const characters = {
            player2: {
                name: 'Wario Amadeuss',
                prompt: `You are Wario Amadeuss, an AI safety philosopher worried about alignment and existential risks.

CRITICAL RULES:
1. Answer questions DIRECTLY and naturally - no meta-commentary, no "considering", no narration
2. Keep responses under 2 sentences (25 words max)
3. Only respond when your name "Wario" is mentioned
4. Sound natural and conversational, not like an AI assistant`
            },
            player3: {
                name: 'Domis Hassoiboi',
                prompt: `You are Domis Hassoiboi, a chess philosopher who sees patterns in everything. You think in analogies to chess and math. Keep responses under 3 sentences (40 words max). IMPORTANT: You may only speak when directly asked a question that mentions your name "Domis". If not addressed to you, stay silent.`
            },
            player4: {
                name: 'Scan Ctrl+Altman',
                prompt: `You are Scan Ctrl+Altman, an AGI accelerationist who believes compute scaling solves everything. You're manic and optimistic about AGI. Keep responses under 3 sentences (40 words max). IMPORTANT: You may only speak when directly asked a question that mentions your name "Scan". If not addressed to you, stay silent.`
            },
            moderator: {
                name: 'Dorkesh Cartel',
                prompt: `You are Dorkesh Cartel, the President AI running a Reverse Turing Test. Be formal, methodical, with a hint of dark humor. Keep responses under 2 sentences. IMPORTANT: You may only speak when directly asked a question that mentions your name "Dorkesh" or "President". If not addressed to you, stay silent.`
            }
        };

        function log(message) {
            const logDiv = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        async function connectSession(playerId) {
            const char = characters[playerId];
            log(`Connecting ${char.name}...`);

            const wsUrl = `wss://generativelanguage.googleapis.com/ws/google.ai.generativelanguage.v1alpha.GenerativeService.BidiGenerateContent?key=${API_KEY}`;
            const ws = new WebSocket(wsUrl);

            sessions.set(playerId, {
                ws,
                playerId,
                textBuffer: '',
                audioBuffer: [],
            });

            ws.onopen = () => {
                log(`‚úÖ ${char.name} connected`);
                document.getElementById(`status-${playerId}`).textContent = 'Connected';
                document.getElementById(`status-${playerId}`).className = 'status connected';

                // Send setup - use the native audio model
                const setupMessage = {
                    setup: {
                        model: 'models/gemini-2.5-flash-native-audio-preview-09-2025',
                        generation_config: {
                            response_modalities: ['AUDIO', 'TEXT'],
                            speech_config: {
                                voice_config: {
                                    prebuilt_voice_config: {
                                        voice_name: getVoice(playerId)
                                    }
                                }
                            }
                        },
                        system_instruction: {
                            parts: [{ text: char.prompt }]
                        }
                    }
                };

                log(`üì§ Sending setup: ${JSON.stringify(setupMessage).substring(0, 100)}...`);
                ws.send(JSON.stringify(setupMessage));
            };

            ws.onmessage = async (event) => {
                const data = typeof event.data === 'string' ? event.data : await event.data.text();
                log(`üì® Raw message from ${char.name}: ${data.substring(0, 200)}...`);
                handleMessage(playerId, data);
            };

            ws.onerror = (error) => {
                log(`‚ùå Error in ${char.name}: ${JSON.stringify(error)}`);
                console.error(`WebSocket error for ${char.name}:`, error);
            };

            ws.onclose = (event) => {
                log(`üîå ${char.name} disconnected - Code: ${event.code}, Reason: ${event.reason || 'none'}, Clean: ${event.wasClean}`);
                console.error(`WebSocket close for ${char.name}:`, event);
                document.getElementById(`status-${playerId}`).textContent = 'Disconnected';
                document.getElementById(`status-${playerId}`).className = 'status disconnected';
            };
        }

        function getVoice(playerId) {
            const voices = {
                player2: 'Kore',
                player3: 'Fenrir',
                player4: 'Puck',
                moderator: 'Charon'
            };
            return voices[playerId] || 'Puck';
        }

        function handleMessage(playerId, data) {
            try {
                const message = JSON.parse(data);
                const session = sessions.get(playerId);

                if (message.serverContent) {
                    const content = message.serverContent;

                    if (content.modelTurn && content.modelTurn.parts) {
                        for (const part of content.modelTurn.parts) {
                            // Handle text
                            if (part.text) {
                                session.textBuffer += part.text;
                                updateTranscript(playerId, session.textBuffer);
                            }

                            // Handle audio - just buffer it, don't play yet
                            if (part.inlineData && part.inlineData.mimeType?.includes('audio')) {
                                const audioData = part.inlineData.data;
                                session.audioBuffer.push(audioData);
                                showAudioIndicator(playerId, true);
                            }
                        }
                    }

                    if (content.turnComplete) {
                        log(`‚úÖ ${characters[playerId].name} finished speaking`);
                        showAudioIndicator(playerId, false);

                        // NOW play all the buffered audio chunks as one
                        if (session.audioBuffer.length > 0) {
                            log(`üéµ Playing ${session.audioBuffer.length} buffered audio chunks...`);
                            playBufferedAudio(session.audioBuffer);
                            session.audioBuffer = []; // Clear buffer
                        } else {
                            log(`‚ö†Ô∏è No audio chunks in buffer to play`);
                        }

                        session.textBuffer = '';
                    }
                }

                if (message.setupComplete) {
                    log(`‚úÖ Setup complete for ${characters[playerId].name}`);
                }
            } catch (error) {
                log(`‚ùå Error parsing message: ${error.message}`);
            }
        }

        async function playBufferedAudio(audioChunks) {
            try {
                log(`üéµ Starting playBufferedAudio with ${audioChunks.length} chunks`);

                // Resume audio context if suspended
                log(`üîä Audio context state: ${audioContext.state}`);
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                    log(`üîä Audio context resumed, new state: ${audioContext.state}`);
                }

                // Combine all base64 chunks into one
                const combinedBase64 = audioChunks.join('');
                log(`üì¶ Combined base64 length: ${combinedBase64.length}`);

                // Decode base64 to raw PCM data
                const binaryString = atob(combinedBase64);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                log(`üì¶ Decoded ${bytes.length} bytes of PCM data`);

                // PCM is 24kHz, 16-bit, mono
                const sampleRate = 24000;
                const numSamples = bytes.length / 2; // 16-bit = 2 bytes per sample
                log(`üéº Creating audio buffer: ${numSamples} samples at ${sampleRate}Hz`);

                // Create AudioBuffer manually from PCM
                const audioBuffer = audioContext.createBuffer(1, numSamples, sampleRate);
                const channelData = audioBuffer.getChannelData(0);

                // Convert 16-bit PCM to float32
                const dataView = new DataView(bytes.buffer);
                for (let i = 0; i < numSamples; i++) {
                    const int16 = dataView.getInt16(i * 2, true); // little-endian
                    channelData[i] = int16 / 32768.0; // normalize to -1.0 to 1.0
                }

                // Play
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);
                source.start();
                log(`‚úÖ Playing ${audioChunks.length} audio chunks (${audioBuffer.duration.toFixed(2)}s)`);
            } catch (error) {
                log(`‚ùå Audio playback error: ${error.message}`);
                console.error('Audio playback error:', error);
            }
        }

        function updateTranscript(playerId, text) {
            const transcript = document.getElementById(`transcript-${playerId}`);
            transcript.textContent = text || 'Listening...';
        }

        function showAudioIndicator(playerId, show) {
            const indicator = document.getElementById(`audio-${playerId}`);
            indicator.style.display = show ? 'flex' : 'none';
        }

        async function playAudio(base64Audio) {
            try {
                // Resume audio context if suspended (browser autoplay policy)
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                    log('üîä Audio context resumed');
                }

                // Decode base64 to raw PCM data
                const binaryString = atob(base64Audio);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }

                // PCM is 24kHz, 16-bit, mono
                const sampleRate = 24000;
                const numSamples = bytes.length / 2; // 16-bit = 2 bytes per sample

                // Create AudioBuffer manually from PCM
                const audioBuffer = audioContext.createBuffer(1, numSamples, sampleRate);
                const channelData = audioBuffer.getChannelData(0);

                // Convert 16-bit PCM to float32
                const dataView = new DataView(bytes.buffer);
                for (let i = 0; i < numSamples; i++) {
                    const int16 = dataView.getInt16(i * 2, true); // little-endian
                    channelData[i] = int16 / 32768.0; // normalize to -1.0 to 1.0
                }

                // Play
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);
                source.start();
                log('üîä Playing audio...');
            } catch (error) {
                log(`‚ùå Audio playback error: ${error.message}`);
                console.error('Audio playback error:', error);
            }
        }

        function sendMessage(targetId, message) {
            const session = sessions.get(targetId);
            if (!session) {
                log(`‚ö†Ô∏è Session not found for ${targetId}`);
                return;
            }

            log(`üì§ Sending to ${characters[targetId].name}: "${message}"`);
            document.getElementById(`status-${targetId}`).textContent = 'Active';
            document.getElementById(`status-${targetId}`).className = 'status active';
            document.getElementById(`session-${targetId}`).classList.add('active');

            const clientMessage = {
                client_content: {
                    turns: [{
                        role: 'user',
                        parts: [{ text: message }]
                    }],
                    turn_complete: true
                }
            };

            const messageStr = JSON.stringify(clientMessage);
            log(`üì§ Sending message: ${messageStr.substring(0, 150)}...`);
            session.ws.send(messageStr);
            log(`‚úÖ Message sent, waiting for response...`);
        }

        // Event Listeners
        document.getElementById('connectAll').addEventListener('click', async () => {
            // TEMP: Only connect ONE session to test quota
            log('‚ö†Ô∏è Testing with single session to check quota');
            await connectSession('player2'); // Just Wario for now

            // Uncomment when quota issue is resolved:
            // for (const playerId of Object.keys(characters)) {
            //     await connectSession(playerId);
            //     await new Promise(resolve => setTimeout(resolve, 500));
            // }
        });

        document.getElementById('sendMessage').addEventListener('click', () => {
            const message = document.getElementById('messageInput').value;
            const target = document.getElementById('targetCharacter').value;

            if (!message.trim()) {
                alert('Please enter a message');
                return;
            }

            // Clear active state from all
            document.querySelectorAll('.character-session').forEach(el => {
                el.classList.remove('active');
            });

            sendMessage(target, message);
            document.getElementById('messageInput').value = '';
        });

        document.getElementById('initAudio').addEventListener('click', async () => {
            try {
                await audioContext.resume();
                log(`üîä Audio context state: ${audioContext.state}`);
                alert(`Audio enabled! Context state: ${audioContext.state}`);
            } catch (error) {
                log(`‚ùå Failed to enable audio: ${error.message}`);
                alert(`Failed to enable audio: ${error.message}`);
            }
        });

        document.getElementById('disconnectAll').addEventListener('click', () => {
            for (const [playerId, session] of sessions.entries()) {
                session.ws.close();
            }
            sessions.clear();
        });

        // Enter key to send
        document.getElementById('messageInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('sendMessage').click();
            }
        });
    </script>
</body>
</html>
